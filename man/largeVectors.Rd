% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RJuliaConnect.R
\docType{class}
\name{largeVectors}
\alias{largeVectors}
\title{Internal Computations for Large Vectors}
\description{
Internal Computations for Large Vectors
}
\section{Sending Large Vectors to Julia}{

Large vectors will be slow to transfer as JSON, and may fail in Julia.  Internal computations have
been added to transfer vectors of types real, integer, logical and character by more direct
computations when they are large.  The computations, some limitations and their implementation are
described here.


R and Julia both have the concept of numeric (floating point) and integer arrays whose elements have a consistent type and both implement
these (following Fortran) as contiguous blocks in memory, augmented by length or dimension information.

JSON has no such concept, so interface evaluators using the standard JSON form provided by 'XR' must send such data as a JSON list.  This will
become inefficient for very large data of these classes.  Users have reported failure by Julia to
parse the corresponding JSON.

The 'XRJulia' package (as of version 0.7.9) implements special code to send vectors to Julia, by
writing an intermediate file that Julia reads.  The actual text sent to Julia is a call to the
relevant Julia function.  The code is triggered within the methods for the \code{asServerObject}
function, so vectors should be transferred this way whether on their own or as part of a larger structure,
such as an array or the column of a data frame.

For numeric, integer and logical vectors, the method uses binary writes and reads, which are defined
in both R and Julia.  For logicals, the internal representation in R corresponds to an integer, which
the Julia side casts to a boolean array.

Character vectors cannot be handled this way, partly because of a weirdness in binary reads and writes
for string arrays in Julia.  Where R character vectors can be written in binary form and then read
back in, writing a String array in Julia effectively writes a single string, which cannot then
be recovered.  The current workaround is to write the vector as lines of text, which Julia then reads.
The limitation is that new line characters within the text will break this, so R checks this by
reading the file back and checking the length of the vector.  If the check fails, the default JSON
method will be used.  If you guarantee there are no new lines internally, the check can be
surpressed by setting the option: \code{options(noNewLines = TRUE)}.

A large object is currently defined as a vector of length greater than the integer field \code{largeObject}
in the evaluator.  By default, this is 1000L, but can be changed either at initialization of the
evaluator or later.
}

